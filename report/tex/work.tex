\section{Work performed}

\subsection{Implementation choices}

FIXME

\subsection{How to use the project}

\begin{noindent}
The project can be downloaded at this address : \\
\url{https://github.com/St0rmingBr4in/ada_stm32}
\end{noindent}

\subsubsection{Requirements}

The project runs on an ARM card: the `STM32F429DICSO`. In order to be able to
build and run this project, here is what you will need:

\begin{itemize}
	\item An STM32F429DICSO ARM board
	\item A linux distribution. We used ArchLinux
    \item A gnat toolchain to cross-compile Ada into an ARM binary
		(\url{https://www.adacore.com/download})
	\item The \textit{gprbuild} and \textit{gprconf} linux tools
	\item The \textit{st-flash} linux utility, to flash the ARM binary created on the
		  device
\end{itemize}

\subsubsection{Building and running the project}

Once you have made sure that your setup fulfills the requirements, you can
move on and try to build and run the project. There are several steps to
building this project, but we wrapped it all up into a Makefile so that simply
invoking the `make` command will perform all the work.

The first thing to do is to build the source files into an ARM ELF file, using
\textit{gprbuild}:\\
gprbuild -XBUILD=\{Debug/Release\} square\_destroyer.gpr
The \textit{square\_destroyer.gpr} file is a configuration file that specifies
how the toolchain is going to run and what tools and target platform it will
use to create the ELF file, as well as where to fetch the Ada source files.

The next step is to copy only the part of the binary we are interested in into
a new file. This new file actually be the code that we flash onto the board,
on which the CPU will jump after the system boots. To do so, we use the
\textit{objcopy} utility from the cross-compilation toolchain:\\
arm-none-eabi-objcopy -O binary main.elf main.bin
\newpage

\subsection{Implementation of the game}

\subsubsection{Implementation of a random \sq generator}

In order to generate \sqs we chose to use the STM32 Library.
Indeed, the library helps generate random number by utilizing the RTC on the \stmdb.

\paragraph{Code}

\noindent
First we include STM32.RNG.Interrupts.
\begin{lstlisting}
   with STM32.RNG.Interrupts; use STM32;
\end{lstlisting}


\noindent
Then we initialize the random number generator using this statement:
\begin{lstlisting}
   RNG.Interrupts.Initialize_RNG;
\end{lstlisting}


\noindent
Finally we can generate our random \sqs like this:


\lstinputlisting[numbers=left,firstline=52, lastline=56]{../src/square_destroyer.adb}

\newpage

\subsubsection{Implementation of Is$\_$Move$\_$Legal}

This procedure verifies that a move is legal. (i.e.\  the move generates a combination of at least 3 \sqs)

\paragraph{Code}
\noindent
\begin{centering}
\lstinputlisting[numbers=left,firstline=156, lastline=179]{../src/square_destroyer.adb}
\end{centering}
\newpage

The Is$\_$Move$\_$Legal procedure uses the helper procedure Get$\_$Matching$\_$Neighbours which helps in getting all the adjacent \sqs of the same color.

\paragraph{Code}
\noindent
\begin{centering}
\lstinputlisting[numbers=left,firstline=135, lastline=154]{../src/square_destroyer.adb}
\end{centering}
\newpage

\subsubsection{Implementation of Draw$\_$Grid}

This procedure draws the \grid onto the screen of the \stmdb.

\paragraph{Code}
\noindent
\begin{centering}
\lstinputlisting[numbers=left,firstline=351, lastline=370]{../src/square_destroyer.adb}
\end{centering}
\newpage

\subsubsection{Implementation of Run}

This procedure is the main game loop.

\paragraph{Code}
\begin{centering}
\lstinputlisting[numbers=left,firstline=374, lastline=415]{../src/square_destroyer.adb}
\end{centering}
\newpage
